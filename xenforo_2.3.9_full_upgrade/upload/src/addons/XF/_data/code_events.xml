<?xml version="1.0" encoding="utf-8"?>
<code_events>
  <event event_id="activity_summary_global_display_values" arguments="[{&quot;name&quot;:&quot;&amp;$globalDisplayValues&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;an array containing global display values&quot;}]"><![CDATA[<p>Called before a set of activity summary emails are sent.</p>

<p>This can be used to set global display values to be displayed at the top of the activity summary email.</p>

<p>Global display values are useful for displaying stats that are relevant to all users, such as the number of users who have registered recently.</p>

<p>Example:</p>
<pre>public static function activitySummaryGlobalDisplayValues(array &$globalDisplayValues): void
{
	$globalDisplayValues[] = [
		'label' => 'some_phrase_title', // can be phrase title or phrase object
		'value' => 1000 // value to display
	];
}</pre>]]></event>
  <event event_id="activity_summary_instance_display_values" arguments="[{&quot;name&quot;:&quot;&amp;$instance&quot;,&quot;type&quot;:&quot;\\XF\\ActivitySummary\\Instance&quot;,&quot;description&quot;:&quot;the Instance object for the activity summary email we are about to send&quot;}]"><![CDATA[<p>Called before a specific activity summary email is sent to a user.</p>

<p>This can be used to set per-instance (per-user) display values to be set at the top of the activity summary email.</p>

<p>Instance specific display values are useful for displaying stats that are relevant to a specific user, such as their reaction score or alerts count.</p>

<p>Example:</p>
<pre>public static function activitySummaryInstanceDisplayValues(\XF\ActivitySummary\Instance &$instance): void
{
	$instance->addDisplayValue(
		'some_phrase_title', // can be phrase title or phrase object
		1000 // value to display
	);
}</pre>]]></event>
  <event event_id="addon_get_install_data" arguments="[{&quot;name&quot;:&quot;&amp;$tableData&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array containing \\XF\\Install\\Data\\AbstractMySQL objects, keyed by addon_id&quot;}]"><![CDATA[<p>Called by the <code><em>xf:repair-db</em></code> CLI command.</p>

<p>Expects a <code><em>\XF\Install\Data\AbstractMySQL</em></code> object, 
	implementing <code><em>getTables()</em></code> and <code><em>getData()</em></code> 
	to be added to the incoming array, keyed by the addon_id,
	to facilitate (re)creation of any missing database tables.</p>]]></event>
  <event event_id="addon_post_install" arguments="[{&quot;name&quot;:&quot;$addOn&quot;,&quot;type&quot;:&quot;\\XF\\AddOn\\AddOn&quot;,&quot;description&quot;:&quot;The AddOn object for the add-on being installed&quot;},{&quot;name&quot;:&quot;$installedAddOn&quot;,&quot;type&quot;:&quot;\\XF\\Entity\\AddOn&quot;,&quot;description&quot;:&quot;The newly created add-on entity&quot;},{&quot;name&quot;:&quot;$json&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array decoded from the add-on's addon.json file&quot;},{&quot;name&quot;:&quot;&amp;$stateChanges&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array for storing state changes such as post-install controller redirects&quot;}]" hint_description="The add-on ID for the add-on being installed."><![CDATA[<p>Called when the post-install code for an add-on has been run.</p>]]></event>
  <event event_id="addon_post_rebuild" arguments="[{&quot;name&quot;:&quot;$addOn&quot;,&quot;type&quot;:&quot;\\XF\\AddOn\\AddOn&quot;,&quot;description&quot;:&quot;The AddOn object for the add-on being rebuilt&quot;},{&quot;name&quot;:&quot;$installedAddOn&quot;,&quot;type&quot;:&quot;\\XF\\Entity\\AddOn&quot;,&quot;description&quot;:&quot;The add-on entity&quot;},{&quot;name&quot;:&quot;$json&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array decoded from the add-on's addon.json file&quot;}]" hint_description="The add-on ID for the add-on being rebuilt."><![CDATA[<p>Called when the post-rebuild code for an add-on has been run.</p>]]></event>
  <event event_id="addon_post_uninstall" arguments="[{&quot;name&quot;:&quot;$addOn&quot;,&quot;type&quot;:&quot;\\XF\\AddOn\\AddOn&quot;,&quot;description&quot;:&quot;The AddOn object for the add-on being uninstalled&quot;},{&quot;name&quot;:&quot;$addOnId&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;ID of the now uninstalled add-on&quot;},{&quot;name&quot;:&quot;$json&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array decoded from the add-on's addon.json file&quot;}]" hint_description="The add-on ID for the add-on being uninstalled."><![CDATA[<p>Called after an add-on has been uninstalled. Although the add-on's record has been removed from the database, the <code>$addOn</code> parameter still provides an in-memory AddOn object containing the pre-uninstall data. The <code>$addOnId</code> parameter contains the ID of the now-uninstalled add-on.</p>]]></event>
  <event event_id="addon_post_upgrade" arguments="[{&quot;name&quot;:&quot;$addOn&quot;,&quot;type&quot;:&quot;\\XF\\AddOn\\AddOn&quot;,&quot;description&quot;:&quot;The AddOn object for the add-on being upgraded&quot;},{&quot;name&quot;:&quot;$installedAddOn&quot;,&quot;type&quot;:&quot;\\XF\\Entity\\AddOn&quot;,&quot;description&quot;:&quot;The existing add-on entity&quot;},{&quot;name&quot;:&quot;$json&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array decoded from the add-on's addon.json file&quot;},{&quot;name&quot;:&quot;&amp;$stateChanges&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array for storing state changes such as post-upgrade controller redirects&quot;}]" hint_description="The add-on ID for the add-on being upgraded."><![CDATA[<p>Called when the post-upgrade code for an add-on has been run.</p>]]></event>
  <event event_id="addon_pre_install" arguments="[{&quot;name&quot;:&quot;$addOn&quot;,&quot;type&quot;:&quot;\\XF\\AddOn\\AddOn&quot;,&quot;description&quot;:&quot;The AddOn object for the add-on being installed&quot;},{&quot;name&quot;:&quot;$installedAddOn&quot;,&quot;type&quot;:&quot;\\XF\\Entity\\AddOn&quot;,&quot;description&quot;:&quot;The newly created add-on entity&quot;},{&quot;name&quot;:&quot;$json&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array decoded from the add-on's addon.json file&quot;}]" hint_description="The add-on ID for the add-on being installed."><![CDATA[<p>Called when the pre-install code for an add-on has been run.</p>]]></event>
  <event event_id="addon_pre_rebuild" arguments="[{&quot;name&quot;:&quot;$addOn&quot;,&quot;type&quot;:&quot;\\XF\\AddOn\\AddOn&quot;,&quot;description&quot;:&quot;The AddOn object for the add-on being rebuilt&quot;},{&quot;name&quot;:&quot;$installedAddOn&quot;,&quot;type&quot;:&quot;\\XF\\Entity\\AddOn&quot;,&quot;description&quot;:&quot;The add-on entity&quot;},{&quot;name&quot;:&quot;$json&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array decoded from the add-on's addon.json file&quot;}]" hint_description="The add-on ID for the add-on being rebuilt."><![CDATA[<p>Called when the pre-rebuild code for an add-on has been run.</p>]]></event>
  <event event_id="addon_pre_uninstall" arguments="[{&quot;name&quot;:&quot;$addOn&quot;,&quot;type&quot;:&quot;\\XF\\AddOn\\AddOn&quot;,&quot;description&quot;:&quot;The AddOn object for the add-on being uninstalled&quot;},{&quot;name&quot;:&quot;$installedAddOn&quot;,&quot;type&quot;:&quot;\\XF\\Entity\\AddOn&quot;,&quot;description&quot;:&quot;The add-on entity&quot;},{&quot;name&quot;:&quot;$json&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array decoded from the add-on's addon.json file&quot;}]" hint_description="The add-on ID for the add-on being uninstalled."><![CDATA[<p>Called when the pre-uninstall code for an add-on has been run.</p>]]></event>
  <event event_id="addon_pre_upgrade" arguments="[{&quot;name&quot;:&quot;$addOn&quot;,&quot;type&quot;:&quot;\\XF\\AddOn\\AddOn&quot;,&quot;description&quot;:&quot;The AddOn object for the add-on being upgraded&quot;},{&quot;name&quot;:&quot;$installedAddOn&quot;,&quot;type&quot;:&quot;\\XF\\Entity\\AddOn&quot;,&quot;description&quot;:&quot;The existing add-on entity&quot;},{&quot;name&quot;:&quot;$json&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array decoded from the add-on's addon.json file&quot;}]" hint_description="The add-on ID for the add-on being upgraded."><![CDATA[<p>Called when the pre-upgrade code for an add-on has been run.</p>]]></event>
  <event event_id="app_admin_complete" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Admin\\App&quot;,&quot;description&quot;:&quot;Admin App object&quot;},{&quot;name&quot;:&quot;&amp;$response&quot;,&quot;type&quot;:&quot;\\XF\\Http\\Response&quot;,&quot;description&quot;:&quot;HTTP Response object&quot;}]"><![CDATA[<p>Called after the admin <code>\XF\Admin\App</code> object has finished running, but before the response is filtered and returned.</p>]]></event>
  <event event_id="app_admin_registry_preload" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Admin\\App&quot;,&quot;description&quot;:&quot;The admin app object&quot;},{&quot;name&quot;:&quot;&amp;$keys&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array of keys to preload from the registry&quot;}]"><![CDATA[<p>Called during the admin <code>\XF\Admin\App</code> object setup.</p>]]></event>
  <event event_id="app_admin_render_page" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Admin\\App&quot;,&quot;description&quot;:&quot;Admin App object&quot;},{&quot;name&quot;:&quot;&amp;$params&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of params being passed into the (container) template&quot;},{&quot;name&quot;:&quot;&amp;$reply&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Reply\\AbstractReply&quot;,&quot;description&quot;:&quot;Reply object&quot;},{&quot;name&quot;:&quot;&amp;$renderer&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Renderer\\AbstractRenderer&quot;,&quot;description&quot;:&quot;Renderer object&quot;}]"><![CDATA[<p>Called just before the admin page HTML is rendered.</p>]]></event>
  <event event_id="app_admin_setup" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Admin\\App&quot;,&quot;description&quot;:&quot;Admin App object&quot;}]"><![CDATA[<p>Called after the admin <code>\XF\Admin\App</code> object has been setup.</p>]]></event>
  <event event_id="app_admin_start_begin" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Admin\\App&quot;,&quot;description&quot;:&quot;Admin App object&quot;}]"><![CDATA[<p>Called at the beginning of the Admin <code>\XF\Admin\App</code> object startup process.</p>]]></event>
  <event event_id="app_admin_start_end" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Admin\\App&quot;,&quot;description&quot;:&quot;Admin App object&quot;}]"><![CDATA[<p>Called at the end of the Admin <code>\XF\Admin\App</code> object startup process.</p>]]></event>
  <event event_id="app_api_complete" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Api\\App&quot;,&quot;description&quot;:&quot;API App object&quot;},{&quot;name&quot;:&quot;&amp;$response&quot;,&quot;type&quot;:&quot;\\XF\\Http\\Response&quot;,&quot;description&quot;:&quot;HTTP Response object&quot;}]"><![CDATA[<p>Called after the API <code>\XF\Api\App</code> object has finished running, but before the response is filtered and returned.</p>]]></event>
  <event event_id="app_api_registry_preload" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Api\\App&quot;,&quot;description&quot;:&quot;The API app object&quot;},{&quot;name&quot;:&quot;&amp;$keys&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array of keys to preload from the registry&quot;}]"><![CDATA[<p>Called during the API <code>\XF\Api\App</code> object setup.</p>]]></event>
  <event event_id="app_api_setup" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Api\\App&quot;,&quot;description&quot;:&quot;API App object&quot;}]"><![CDATA[<p>Called after the API <code>\XF\Api\App</code> object has been setup.</p>]]></event>
  <event event_id="app_api_start_begin" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Api\\App&quot;,&quot;description&quot;:&quot;API App object&quot;}]"><![CDATA[<p>Called at the beginning of the API <code>\XF\Api\App</code> object startup process.</p>]]></event>
  <event event_id="app_api_start_end" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Api\\App&quot;,&quot;description&quot;:&quot;API App object&quot;}]"><![CDATA[<p>Called at the end of the API <code>\XF\Api\App</code> object startup process.</p>]]></event>
  <event event_id="app_api_validate_request" arguments="[{&quot;name&quot;:&quot;$request&quot;,&quot;type&quot;:&quot;\\XF\\Http\\Request&quot;,&quot;description&quot;:&quot;HTTP request object&quot;},{&quot;name&quot;:&quot;$result&quot;,&quot;type&quot;:&quot;\\XF\\Entity\\User|false|null&quot;,&quot;description&quot;:&quot;if overriding the behavior, set this to a user entity or false&quot;},{&quot;name&quot;:&quot;$error&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;if setting the result to false, the phrase key of the error to return&quot;},{&quot;name&quot;:&quot;$code&quot;,&quot;type&quot;:&quot;int&quot;,&quot;description&quot;:&quot;if setting the result to false, the HTTP response code to use&quot;}]"><![CDATA[<p>Called in the process of starting the <code>\XF\Api\App</code> object, when validating the API request credentials.</p>

<p>To override the default behavior, set <code>$result</code> to a user entity or, if triggering an error, false. If an error is triggered, set <code>$error</code> and <code>$code</code> as appropriate.</p>

<p>
	Alternatively, a <code><em>\XF\Http\Response</em></code> object may be returned to directly output a completely custom response. This can be used for more advanced error handling, for example.
</p>]]></event>
  <event event_id="app_cli_registry_preload" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Cli\\App&quot;,&quot;description&quot;:&quot;The CLI app object&quot;},{&quot;name&quot;:&quot;&amp;$keys&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array of keys to preload from the registry&quot;}]"><![CDATA[<p>Called during the CLI <code>\XF\Cli\App</code> object setup.</p>]]></event>
  <event event_id="app_cli_setup" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Cli\\App&quot;,&quot;description&quot;:&quot;CLI App object&quot;}]"><![CDATA[Called after the CLI \XF\Cli\App object has been set up.]]></event>
  <event event_id="app_cli_start_begin" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Cli\\App&quot;,&quot;description&quot;:&quot;CLI App object&quot;}]"><![CDATA[<p>Called at the beginning of the CLI <code>\XF\Cli\App</code> object startup process.</p>]]></event>
  <event event_id="app_cli_start_end" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Cli\\App&quot;,&quot;description&quot;:&quot;CLI App object&quot;}]"><![CDATA[<p>Called at the end of the CLI <code>\XF\Cli\App</code> object startup process.</p>]]></event>
  <event event_id="app_complete" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\App&quot;,&quot;description&quot;:&quot;Global App object&quot;},{&quot;name&quot;:&quot;&amp;$response&quot;,&quot;type&quot;:&quot;\\XF\\Http\\Response&quot;,&quot;description&quot;:&quot;HTTP Response object&quot;}]"><![CDATA[<p>Called after the global <code>\XF\App</code> object has finished running, but before the response is filtered and returned.</p>]]></event>
  <event event_id="app_final_output" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\App&quot;,&quot;description&quot;:&quot;Global App object&quot;},{&quot;name&quot;:&quot;&amp;$response&quot;,&quot;type&quot;:&quot;\\XF\\Http\\Response&quot;,&quot;description&quot;:&quot;HTTP Response object&quot;}]"><![CDATA[<p>Called just before the HTTP response returned.</p>]]></event>
  <event event_id="app_pub_complete" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Pub\\App&quot;,&quot;description&quot;:&quot;Public App object&quot;},{&quot;name&quot;:&quot;&amp;$response&quot;,&quot;type&quot;:&quot;\\XF\\Http\\Response&quot;,&quot;description&quot;:&quot;HTTP Response object&quot;}]"><![CDATA[<p>Called after the public <code>\XF\Pub\App</code> object has finished running, but before the response is filtered and returned.</p>]]></event>
  <event event_id="app_pub_registry_preload" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Pub\\App&quot;,&quot;description&quot;:&quot;The public app object&quot;},{&quot;name&quot;:&quot;&amp;$keys&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array of keys to preload from the registry&quot;}]"><![CDATA[<p>Called during the public <code>\XF\Pub\App</code> object setup.</p>]]></event>
  <event event_id="app_pub_render_page" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Pub\\App&quot;,&quot;description&quot;:&quot;Public App object&quot;},{&quot;name&quot;:&quot;&amp;$params&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of params being passed into the (container) template&quot;},{&quot;name&quot;:&quot;$reply&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Reply\\AbstractReply&quot;,&quot;description&quot;:&quot;Reply object&quot;},{&quot;name&quot;:&quot;$renderer&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Renderer\\AbstractRenderer&quot;,&quot;description&quot;:&quot;Renderer object&quot;}]"><![CDATA[<p>Called just before the public page HTML is rendered.</p>]]></event>
  <event event_id="app_pub_setup" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Pub\\App&quot;,&quot;description&quot;:&quot;Public App object&quot;}]"><![CDATA[<p>Called after the public <code>\XF\Pub\App</code> object has been setup.</p>]]></event>
  <event event_id="app_pub_start_begin" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Pub\\App&quot;,&quot;description&quot;:&quot;Public App object&quot;}]"><![CDATA[<p>Called at the beginning of the Public <code>\XF\Pub\App</code> object startup process.</p>]]></event>
  <event event_id="app_pub_start_end" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Pub\\App&quot;,&quot;description&quot;:&quot;Public App object&quot;}]"><![CDATA[<p>Called at the end of the Public <code>\XF\Pub\App</code> object startup process.</p>]]></event>
  <event event_id="app_registry_preload" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\App&quot;,&quot;description&quot;:&quot;The global app object&quot;},{&quot;name&quot;:&quot;&amp;$keys&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array of keys to preload from the registry&quot;}]"><![CDATA[<p>Called during the global <code>\XF\App</code> object setup. This will fire regardless of the application type.</p>]]></event>
  <event event_id="app_setup" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\App&quot;,&quot;description&quot;:&quot;Global App object&quot;}]"><![CDATA[<p>Called after the global <code>\XF\App</code> object has been setup. This will fire regardless of the application type.</p>]]></event>
  <event event_id="bb_code_processor_action_map" arguments="[{&quot;name&quot;:&quot;&amp;$processorActionMap&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;The current processor action map&quot;}]"><![CDATA[<p>Called when the BB code processor action map is accessed.</p>]]></event>
  <event event_id="bb_code_renderer" arguments="[{&quot;name&quot;:&quot;$renderer&quot;,&quot;type&quot;:&quot;\\XF\\BbCode\\Renderer\\AbstractRenderer&quot;,&quot;description&quot;:&quot;The renderer object being created&quot;},{&quot;name&quot;:&quot;$type&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;A string representing the type of renderer that is being created (such as \&quot;html\&quot; or \&quot;editorHtml\&quot;)&quot;}]" hint_description="The type of renderer being created."><![CDATA[<p>Called when a BB code renderer object is created.</p>]]></event>
  <event event_id="bb_code_renderer_map" arguments="[{&quot;name&quot;:&quot;&amp;$rendererMap&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;The current renderer map&quot;}]"><![CDATA[<p>Called when the BB code renderer map is accessed.</p>]]></event>
  <event event_id="bb_code_rules" arguments="[{&quot;name&quot;:&quot;$ruleSet&quot;,&quot;type&quot;:&quot;\\XF\\BbCode\\RuleSet&quot;,&quot;description&quot;:&quot;The ruleset object being created&quot;},{&quot;name&quot;:&quot;$context&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;A string representing the context of the rule set, usually representing the content type&quot;},{&quot;name&quot;:&quot;$subContext&quot;,&quot;type&quot;:&quot;string|null&quot;,&quot;description&quot;:&quot;A string representing the sub-context of the rule set. This may not always be provided, but can represent a specific situation (such as \&quot;rss\&quot;)&quot;}]" hint_description="The context for the rule set (not including the sub-context)."><![CDATA[<p>Called when a BB code rule set object is created.</p>]]></event>
  <event event_id="code_languages" arguments="[{&quot;name&quot;:&quot;&amp;$languages&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of languages which can be modified&quot;}]"><![CDATA[<p>Allows the modification of the list of supported code languages as defined in <code>XF\Data\CodeLanguage</code>. This allows you to modify the CodeMirror "mode" which is enabled when that language is selected in the code editor, whether it is "common" (so it appears at the top of the list) and which CodeMirror add-ons are enabled when that mode is selected.</p>]]></event>
  <event event_id="controller_post_dispatch" arguments="[{&quot;name&quot;:&quot;$controller&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Controller&quot;,&quot;description&quot;:&quot;Main controller object&quot;},{&quot;name&quot;:&quot;$action&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Current controller action&quot;},{&quot;name&quot;:&quot;$params&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\ParameterBag&quot;,&quot;description&quot;:&quot;ParameterBag object containing router related params&quot;},{&quot;name&quot;:&quot;&amp;$reply&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Reply\\AbstractReply&quot;,&quot;description&quot;:&quot;Reply object&quot;}]" hint_description="Fully qualified name of the root class that was called."><![CDATA[<p>Called at the end of the <code>postDispatch()</code> method of the main <code>Controller</code> object.</p>]]></event>
  <event event_id="controller_pre_dispatch" arguments="[{&quot;name&quot;:&quot;$controller&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Controller&quot;,&quot;description&quot;:&quot;Main controller object&quot;},{&quot;name&quot;:&quot;$action&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Current controller action&quot;},{&quot;name&quot;:&quot;$params&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\ParameterBag&quot;,&quot;description&quot;:&quot;ParameterBag object containing router related params&quot;}]" hint_description="Fully qualified name of the root class that was called."><![CDATA[<p>Called at the end of the <code>preDispatch()</code> method of the main <code>Controller</code> object.</p>]]></event>
  <event event_id="cookie_consent_setup" arguments="[{&quot;name&quot;:&quot;$cookieConsent&quot;,&quot;type&quot;:&quot;\\XF\\CookieConsent&quot;,&quot;description&quot;:&quot;Cookie consent object&quot;}]"><![CDATA[<p>Called after the <code>\XF\CookieConsent</code> object has been setup.</p>]]></event>
  <event event_id="criteria_page" arguments="[{&quot;name&quot;:&quot;$rule&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;text identifying the criteria that should be checked&quot;},{&quot;name&quot;:&quot;$data&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;data defining the conditions of the criteria&quot;},{&quot;name&quot;:&quot;$user&quot;,&quot;type&quot;:&quot;\\XF\\Entity\\User&quot;,&quot;description&quot;:&quot;user entity object to be used in the criteria checks&quot;},{&quot;name&quot;:&quot;$params&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;container and template parameters to use in the criteria checks&quot;},{&quot;name&quot;:&quot;&amp;$returnValue&quot;,&quot;type&quot;:&quot;bool&quot;,&quot;description&quot;:&quot;the event code should set this to true if a criteria check succeeds&quot;}]"><![CDATA[<p>Called while testing a page against various criteria in \XF\Criteria\Page::isMatch() for notices etc.</p>

<p>Example:</p>
<pre>public static function criteriaPage($rule, array $data, \XF\Entity\User $user, array $params, &amp;$returnValue)
{
	switch ($rule)
	{
		case 'p_field':
		if ($params['p'] == $data['p_value'])
		{
			$returnValue = true;
		}
		break;
		
		case 'c_check':
		if ($params['c'] == $data['c'])
		{
			$returnValue = true;
		}
		break;
	}
}</pre>]]></event>
  <event event_id="criteria_template_data" arguments="[{&quot;name&quot;:&quot;&amp;$templateData&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;the array of data passed to the helper_criteria_template&quot;},{&quot;name&quot;:&quot;$criteria&quot;,&quot;type&quot;:&quot;\\XF\\Criteria\\AbstractCriteria&quot;,&quot;description&quot;:&quot;the criteria object rendering the helper_criteria_template&quot;}]"><![CDATA[<p>Called before rendering the helper_criteria template to allow adding additional view params to the criteria form.</p>]]></event>
  <event event_id="criteria_user" arguments="[{&quot;name&quot;:&quot;$rule&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;text identifying the criteria that should be checked&quot;},{&quot;name&quot;:&quot;$data&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;data defining the conditions of the criteria&quot;},{&quot;name&quot;:&quot;$user&quot;,&quot;type&quot;:&quot;\\XF\\Entity\\User&quot;,&quot;description&quot;:&quot;user entity object to be used in the criteria checks&quot;},{&quot;name&quot;:&quot;&amp;$returnValue&quot;,&quot;type&quot;:&quot;bool&quot;,&quot;description&quot;:&quot;the event code should set this to true if a criteria check matches&quot;}]"><![CDATA[<p>Called while testing a user against user criteria in \XF\Criteria\User::isMatch() for trophies, notices etc.</p>

<p>Example:</p>
<pre>public static function criteriaUser($rule, array $data, \XF\Entity\User $user, &amp;$returnValue)
{
	switch ($rule)
	{
		case 'foo_field':
		if ($user['foo_field'] == $data['foo'])
		{
			$returnValue = true;
		}
		break;
		
		case 'bar_field':
		if ($user['bar_field'] == $data['bar_value'])
		{
			$returnValue = true;
		}
		break;
	}
}</pre>]]></event>
  <event event_id="criteria_webhook" arguments="[{&quot;name&quot;:&quot;$rule&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;text identifying the criteria that should be checked&quot;},{&quot;name&quot;:&quot;$criteria&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;data defining the conditions of the criteria&quot;},{&quot;name&quot;:&quot;$data&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;the payload data being sent and which criteria should be checked against&quot;},{&quot;name&quot;:&quot;$contentType&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;text identifying the content type of the payload data&quot;},{&quot;name&quot;:&quot;&amp;$returnValue&quot;,&quot;type&quot;:&quot;bool&quot;,&quot;description&quot;:&quot;the event code should set this to true if a criteria check matches&quot;}]"><![CDATA[<p>Called while testing a webhook against additional criteria to see if it should be sent in extensions of \XF\Webhook\Criteria\AbstractCriteria::isUnknownMatched().</p>

<p>Example:</p>
<pre>public static function criteriaWebhook(string $rule, array $criteria, array $data, string $contentType, &amp;$returnValue)
{
	switch ($rule)
	{
		case 'foo_field':
		if ($data['foo_field'] == $criteria['foo'])
		{
			$returnValue = true;
		}
		break;
		
		case 'bar_field':
		if ($data['bar_field'] == $criteria['bar_value'])
		{
			$returnValue = true;
		}
		break;
	}
}</pre>]]></event>
  <event event_id="dispatcher_match" arguments="[{&quot;name&quot;:&quot;$dispatcher&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Dispatcher&quot;,&quot;description&quot;:&quot;Dispatcher object&quot;},{&quot;name&quot;:&quot;&amp;$match&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\RouteMatch&quot;,&quot;description&quot;:&quot;Route match object&quot;}]"><![CDATA[<p>Called before the dispatch loop, allows you to modify the \XF\Mvc\RouteMatch object before it is modified.</p>]]></event>
  <event event_id="dispatcher_post_dispatch" arguments="[{&quot;name&quot;:&quot;$dispatcher&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Dispatcher&quot;,&quot;description&quot;:&quot;Dispatcher object&quot;},{&quot;name&quot;:&quot;&amp;$reply&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Reply\\AbstractReply&quot;,&quot;description&quot;:&quot;Reply object&quot;},{&quot;name&quot;:&quot;$routeMatch&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\RouteMatch&quot;,&quot;description&quot;:&quot;Route match object&quot;},{&quot;name&quot;:&quot;$originalMatch&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\RouteMatch&quot;,&quot;description&quot;:&quot;Original route match object&quot;}]"><![CDATA[<p>Called after the app post dispatch method is called and after the Reply and RouteMatch objects have been modified. Also gives access to the original RouteMatch object.</p>]]></event>
  <event event_id="dispatcher_post_render" arguments="[{&quot;name&quot;:&quot;$dispatcher&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Dispatcher&quot;,&quot;description&quot;:&quot;Dispatcher object&quot;},{&quot;name&quot;:&quot;&amp;$content&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;The rendered content&quot;},{&quot;name&quot;:&quot;$reply&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Reply\\AbstractReply&quot;,&quot;description&quot;:&quot;Reply object&quot;},{&quot;name&quot;:&quot;$renderer&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Renderer\\AbstractRenderer&quot;,&quot;description&quot;:&quot;Renderer object&quot;},{&quot;name&quot;:&quot;$response&quot;,&quot;type&quot;:&quot;\\XF\\Http\\Response&quot;,&quot;description&quot;:&quot;HTTP Response object&quot;}]"><![CDATA[<p>Called after the content has been rendered, and before the content is passed to the response body.</p>]]></event>
  <event event_id="dispatcher_pre_dispatch" arguments="[{&quot;name&quot;:&quot;$dispatcher&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Dispatcher&quot;,&quot;description&quot;:&quot;Dispatcher object&quot;},{&quot;name&quot;:&quot;$routeMatch&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\RouteMatch&quot;,&quot;description&quot;:&quot;Route match object&quot;}]"><![CDATA[<p>Called before the app pre dispatch method is called and before the dispatch loop, allows you to modify the original RouteMatch object before it is modified.</p>]]></event>
  <event event_id="dispatcher_pre_render" arguments="[{&quot;name&quot;:&quot;$dispatcher&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Dispatcher&quot;,&quot;description&quot;:&quot;Dispatcher object&quot;},{&quot;name&quot;:&quot;$reply&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Reply\\AbstractReply&quot;,&quot;description&quot;:&quot;Reply object&quot;},{&quot;name&quot;:&quot;$responseType&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Response type as a string, e.g. 'html', 'json' etc&quot;}]"><![CDATA[<p>Called before the app pre render method is called.</p>]]></event>
  <event event_id="editor_button_data" arguments="[{&quot;name&quot;:&quot;&amp;$buttons&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;List of buttons that people can customize their editor toolbar with&quot;},{&quot;name&quot;:&quot;$editorData&quot;,&quot;type&quot;:&quot;\\XF\\Data\\Editor&quot;,&quot;description&quot;:&quot;The editor data object triggering the event&quot;}]"><![CDATA[<p>Fired when loading editor button data for customization in the control panel. This is called before separators or custom dropdowns are added.</p>]]></event>
  <event event_id="editor_dialog" arguments="[{&quot;name&quot;:&quot;&amp;$data&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;The data for the dialog view. Contains 3 keys: view (view class to be loaded), template (name of template to be displayed), and params (array of data to be passed to the view\/template)&quot;},{&quot;name&quot;:&quot;$controller&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Controller&quot;,&quot;description&quot;:&quot;The controller triggering this event&quot;}]" hint_description="The name of the dialog as passed into the XF\Pub\Controller\Editor::loadDialog method. Note the event hint will be an alphanumeric version of the dialog name."><![CDATA[<p>Fired when loading a dialog for the rich text editor.</p>]]></event>
  <event event_id="entity_defaults" arguments="[{&quot;name&quot;:&quot;$entity&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Entity\\Entity&quot;,&quot;description&quot;:&quot;Entity object&quot;}]" hint_description="Fully qualified name of the root class that was called."><![CDATA[<p>Event fires after the default Entity values have been applied. You can set your own defaults directly using <code>$entity->field = 'value';</code>.</p>]]></event>
  <event event_id="entity_post_delete" arguments="[{&quot;name&quot;:&quot;$entity&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Entity\\Entity&quot;,&quot;description&quot;:&quot;Entity object&quot;}]" hint_description="Fully qualified name of the root class that was called."><![CDATA[<p>Event fires after the Entity specific <code>_postDelete()</code> method is called and after the post delete of any behaviors.</p>]]></event>
  <event event_id="entity_post_save" arguments="[{&quot;name&quot;:&quot;$entity&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Entity\\Entity&quot;,&quot;description&quot;:&quot;Entity object&quot;}]" hint_description="Fully qualified name of the root class that was called."><![CDATA[<p>Event fires after the Entity specific <code>_postSave()</code> method is called and after the post save of any behaviors.</p>]]></event>
  <event event_id="entity_pre_delete" arguments="[{&quot;name&quot;:&quot;$entity&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Entity\\Entity&quot;,&quot;description&quot;:&quot;Entity object&quot;}]" hint_description="Fully qualified name of the root class that was called."><![CDATA[<p>Event fires after the Entity specific <code>_preDelete()</code> method is called and after the pre delete of any behaviors.</p>]]></event>
  <event event_id="entity_pre_save" arguments="[{&quot;name&quot;:&quot;$entity&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Entity\\Entity&quot;,&quot;description&quot;:&quot;Entity object&quot;}]" hint_description="Fully qualified name of the root class that was called."><![CDATA[<p>Event fires after the Entity specific <code>_preSave()</code> method is called and after the pre save of any behaviors.</p>]]></event>
  <event event_id="entity_structure" arguments="[{&quot;name&quot;:&quot;$em&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Entity\\Manager&quot;,&quot;description&quot;:&quot;Entity Manager object&quot;},{&quot;name&quot;:&quot;&amp;$structure&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Entity\\Structure&quot;,&quot;description&quot;:&quot;Entity Structure object&quot;}]" hint_description="Fully qualified name of the entity class whose structure is being modified."><![CDATA[<p>Allows direct modification of the Entity structure.</p>]]></event>
  <event event_id="home_page_url" arguments="[{&quot;name&quot;:&quot;&amp;$homePageUrl&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;The current home page URL&quot;},{&quot;name&quot;:&quot;$router&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Router&quot;,&quot;description&quot;:&quot;XF router object&quot;}]"><![CDATA[<p>Allows the overriding of the <code>{$xf.options.homePageUrl}</code> option to a different URL.</p>]]></event>
  <event event_id="http_client_config" arguments="[{&quot;name&quot;:&quot;&amp;$client&quot;,&quot;type&quot;:&quot;\\GuzzleHttp\\Client&quot;,&quot;description&quot;:&quot;Guzzle HTTP client object&quot;}]"><![CDATA[<p>Fired after the default options for the default HTTP client have been applied.</p>]]></event>
  <event event_id="http_client_config_untrusted" arguments="[{&quot;name&quot;:&quot;&amp;$client&quot;,&quot;type&quot;:&quot;\\GuzzleHttp\\Client&quot;,&quot;description&quot;:&quot;Guzzle HTTP client object&quot;}]"><![CDATA[<p>Fired after the untrusted HTTP client has been setup with its default options.</p>]]></event>
  <event event_id="http_client_options" arguments="[{&quot;name&quot;:&quot;&amp;$options&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of options to be passed into the Guzzle HTTP client object&quot;}]"><![CDATA[<p>Fired before the default HTTP client has been setup so its default options can be modified.</p>]]></event>
  <event event_id="http_client_options_untrusted" arguments="[{&quot;name&quot;:&quot;&amp;$options&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of options to be passed into the Guzzle HTTP client object&quot;}]"><![CDATA[<p>Fired before the untrusted HTTP client has been setup so its default options can be modified.</p>]]></event>
  <event event_id="icon_usage_analyzer_extra" arguments="[{&quot;name&quot;:&quot;&amp;$icons&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array of strings containing icon classes, for example 'fas fa-acorn'&quot;}]"><![CDATA[<p>Called when determining which extra icons are currently in use. These icons will be included in the generated sprites.</p>

<p><strong>This is a simple event for adding a static set of icons. For more advanced cases, extend <code>\XF\Service\Icon\UsageAnalyzerService</code> instead.</strong></p>]]></event>
  <event event_id="icon_usage_analyzer_steps" arguments="[{&quot;name&quot;:&quot;&amp;$steps&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of content types to a list of step callables or method names&quot;},{&quot;name&quot;:&quot;$usageAnalyzer&quot;,&quot;type&quot;:&quot;\\XF\\Service\\Icon\\UsageAnalyzerService&quot;,&quot;description&quot;:&quot;Icon usage analyzer service&quot;}]"><![CDATA[<p>Called when determining the icon usage analyzer steps.</p>

<p>Example:</p>
<pre>public static function iconUsageAnalyzerSteps(
	array &$steps,
	\XF\Service\Icon\UsageAnalyzerService $usageAnalyzer
): void
{
	$steps['my_content_type'][] = function (?int $lastOffset, float $maxRunTime) use ($usageAnalyzer): ?int
	{
		// your icon usage analyzer logic
		return null;
	};
}</pre>]]></event>
  <event event_id="import_importer_classes" arguments="[{&quot;name&quot;:&quot;$container&quot;,&quot;type&quot;:&quot;\\XF\\SubContainer\\Import&quot;,&quot;description&quot;:&quot;Import sub-container object&quot;},{&quot;name&quot;:&quot;$parentContainer&quot;,&quot;type&quot;:&quot;\\XF\\Container&quot;,&quot;description&quot;:&quot;Global container object&quot;},{&quot;name&quot;:&quot;&amp;$importers&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of importers&quot;}]"><![CDATA[<p>Fired inside the <code>importers</code> container in the Import sub-container. Add-ons can use this to add additional importer classes to the importer list. The class names can be fully qualified or the short class version e.g. <code>AddOn:ClassName</code>.</p>]]></event>
  <event event_id="inline_mod_actions" arguments="[{&quot;name&quot;:&quot;$handler&quot;,&quot;type&quot;:&quot;\\XF\\InlineMod\\AbstractHandler&quot;,&quot;description&quot;:&quot;Inline moderation handler&quot;},{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\App&quot;,&quot;description&quot;:&quot;Global App object&quot;},{&quot;name&quot;:&quot;&amp;$actions&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of actions already defined for this handler&quot;}]" hint_description="The content type for the desired handler."><![CDATA[<p>Fires when an inline moderation handler is being instantiated. Allows direct modification of the possible actions, allowing additional simple actions and action handlers to be defined for an existing content type.</p>]]></event>
  <event event_id="mailer_setup" arguments="[{&quot;name&quot;:&quot;$container&quot;,&quot;type&quot;:&quot;\\XF\\Container&quot;,&quot;description&quot;:&quot;Dependency injection container object&quot;},{&quot;name&quot;:&quot;&amp;$mailer&quot;,&quot;type&quot;:&quot;\\XF\\Mail\\Mailer&quot;,&quot;description&quot;:&quot;Mailer object&quot;}]"><![CDATA[<p>Fires after the initial setup of the Mailer object inside the global App's "mailer" container.</p>]]></event>
  <event event_id="mailer_transport_setup" arguments="[{&quot;name&quot;:&quot;$container&quot;,&quot;type&quot;:&quot;\\XF\\Container&quot;,&quot;description&quot;:&quot;Dependency injection container object&quot;},{&quot;name&quot;:&quot;&amp;$transport&quot;,&quot;type&quot;:&quot;\\Symfony\\Component\\Mailer\\Transport\\TransportInterface|null&quot;,&quot;description&quot;:&quot;This argument allows you to return the mail transport object override&quot;}]"><![CDATA[<p>This allows you to override the mail transport object with your own approach.</p>

<p>Fires only if the config flag <code>enableMail</code> is true.</p>

<p>See <code>\XF\Mail\Mailer::getTransportFromOption()</code> for more info on transport objects.</p>]]></event>
  <event event_id="member_stat_result_prepare" arguments="[{&quot;name&quot;:&quot;$order&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;The member statistic sort order&quot;},{&quot;name&quot;:&quot;&amp;$cacheResults&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;An array of member statistic result values&quot;}]"><![CDATA[<p>This event makes it possible to format member statistic result values.</p>]]></event>
  <event event_id="mounted_file_write" arguments="[{&quot;name&quot;:&quot;$type&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;the type of file written to (data, internal-data, code-cache, etc)&quot;},{&quot;name&quot;:&quot;$filename&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;the name of the file that has changed&quot;},{&quot;name&quot;:&quot;$event&quot;,&quot;type&quot;:&quot;\\League\\Flysystem\\EventableFilesystem\\Event\\After&quot;,&quot;description&quot;:&quot;the Flysystem event that triggered this. This provides access to more specific information about the change (such as the specific method called and the arguments provided)&quot;}]"><![CDATA[<p>Called when a mounted filesystem file is written to. By default, this includes data, internal data, and code cache files.</p>]]></event>
  <event event_id="navigation_setup" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Pub\\App&quot;,&quot;description&quot;:&quot;Public App object&quot;},{&quot;name&quot;:&quot;&amp;$navigationFlat&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Flat array of navigation entries&quot;},{&quot;name&quot;:&quot;&amp;$navigationTree&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Nested tree of navigation entries, grouped by their applicable parents&quot;}]"><![CDATA[<p>Allows direct modification of the flat and tree versions of the navigation array after it has been rendered from the navigation cache.</p>]]></event>
  <event event_id="notices_setup" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\Pub\\App&quot;,&quot;description&quot;:&quot;Public App object&quot;},{&quot;name&quot;:&quot;$noticeList&quot;,&quot;type&quot;:&quot;\\XF\\NoticeList&quot;,&quot;description&quot;:&quot;NoticeList object&quot;},{&quot;name&quot;:&quot;$pageParams&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of page params&quot;}]"><![CDATA[<p>Allows modification of the <code>\XF\NoticeList</code> object after the default and admin defined (if enabled) notices have been added.</p>]]></event>
  <event event_id="page_cache_id" arguments="[{&quot;name&quot;:&quot;&amp;$pageCacheId&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;The current page cache ID&quot;},{&quot;name&quot;:&quot;$request&quot;,&quot;type&quot;:&quot;\\XF\\Http\\Request&quot;,&quot;description&quot;:&quot;XF request object&quot;}]"><![CDATA[<p>Allows manipulation of the page cache ID for the current request.</p>]]></event>
  <event event_id="router_public_setup" arguments="[{&quot;name&quot;:&quot;$container&quot;,&quot;type&quot;:&quot;\\XF\\Container&quot;,&quot;description&quot;:&quot;Dependency injection container object&quot;},{&quot;name&quot;:&quot;&amp;$router&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Router&quot;,&quot;description&quot;:&quot;Router object&quot;}]"><![CDATA[<p>Fires after the initial setup of the public router inside the global App's "router.public" container.</p>]]></event>
  <event event_id="search_source_setup_22" arguments="[{&quot;name&quot;:&quot;$container&quot;,&quot;type&quot;:&quot;\\XF\\Container&quot;,&quot;description&quot;:&quot;Dependency injection container object&quot;},{&quot;name&quot;:&quot;&amp;$source&quot;,&quot;type&quot;:&quot;\\XF\\Search\\Source\\AbstractSource|null&quot;,&quot;description&quot;:&quot;This argument allows you to return the search source object override. If set, this must be an instance of \\XF\\Search\\Source\\AbstractSource&quot;}]"><![CDATA[<p>This allows you to override the search source object.</p>

<p>Fires when the <code>search.source</code> container is called.</p>

<p>
	<em>Note:</em> This event has been renamed in XenForo 2.2 due to backwards compatibility breaks with the search source system.
</p>]]></event>
  <event event_id="session_public_storage_setup" arguments="[{&quot;name&quot;:&quot;$container&quot;,&quot;type&quot;:&quot;\\XF\\Container&quot;,&quot;description&quot;:&quot;Dependency injection container object&quot;},{&quot;name&quot;:&quot;$cache&quot;,&quot;type&quot;:&quot;\\Doctrine\\Common\\Cache\\CacheProvider|null&quot;,&quot;description&quot;:&quot;Cache provider object (if configured)&quot;},{&quot;name&quot;:&quot;&amp;$storage&quot;,&quot;type&quot;:&quot;\\XF\\Session\\StorageInterface|null&quot;,&quot;description&quot;:&quot;This argument allows you to return the session storage object override. If set, this must be an instance of \\XF\\Session\\StorageInterface&quot;}]"><![CDATA[<p>This allows you to override the public session storage object.</p>

<p>Fires when the <code>session.public.storage</code> container is called.</p>]]></event>
  <event event_id="spam_content_providers" arguments="[{&quot;name&quot;:&quot;$container&quot;,&quot;type&quot;:&quot;\\XF\\SubContainer\\Spam&quot;,&quot;description&quot;:&quot;Spam sub-container object&quot;},{&quot;name&quot;:&quot;$parentContainer&quot;,&quot;type&quot;:&quot;\\XF\\Container&quot;,&quot;description&quot;:&quot;Parent container&quot;},{&quot;name&quot;:&quot;&amp;$providers&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of content checker providers&quot;}]"><![CDATA[<p>Fired inside the <code>contentProviders</code> container in the Spam sub-container.</p>]]></event>
  <event event_id="spam_content_submitter" arguments="[{&quot;name&quot;:&quot;$container&quot;,&quot;type&quot;:&quot;\\XF\\SubContainer\\Spam&quot;,&quot;description&quot;:&quot;Spam sub-container object&quot;},{&quot;name&quot;:&quot;$parentContainer&quot;,&quot;type&quot;:&quot;\\XF\\Container&quot;,&quot;description&quot;:&quot;Parent container&quot;},{&quot;name&quot;:&quot;&amp;$checker&quot;,&quot;type&quot;:&quot;\\XF\\Spam\\ContentChecker&quot;,&quot;description&quot;:&quot;Spam checker object&quot;}]"><![CDATA[<p>Fired inside the <code>contentSubmitter</code> container in the Spam sub-container. The <code>$checker</code> object allows you to add additional providers which will be used to submit details of users and their content when spam is cleaned.</p>]]></event>
  <event event_id="spam_content_submitter_ham" arguments="[{&quot;name&quot;:&quot;$container&quot;,&quot;type&quot;:&quot;\\XF\\SubContainer\\Spam&quot;,&quot;description&quot;:&quot;Spam sub-container object&quot;},{&quot;name&quot;:&quot;$parentContainer&quot;,&quot;type&quot;:&quot;\\XF\\Container&quot;,&quot;description&quot;:&quot;Parent container&quot;},{&quot;name&quot;:&quot;&amp;$checker&quot;,&quot;type&quot;:&quot;\\XF\\Spam\\ContentChecker&quot;,&quot;description&quot;:&quot;Spam checker object&quot;}]"><![CDATA[<p>Fired inside the <code>contentHamSubmitter</code> container in the Spam sub-container. The <code>$checker</code> object allows you to add additional providers which will be used to re-submit details of users and their content when previously detected spam content is approved.</p>]]></event>
  <event event_id="spam_user_providers" arguments="[{&quot;name&quot;:&quot;$container&quot;,&quot;type&quot;:&quot;\\XF\\SubContainer\\Spam&quot;,&quot;description&quot;:&quot;Spam sub-container object&quot;},{&quot;name&quot;:&quot;$parentContainer&quot;,&quot;type&quot;:&quot;\\XF\\Container&quot;,&quot;description&quot;:&quot;Parent container&quot;},{&quot;name&quot;:&quot;&amp;$providers&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of user checker providers&quot;}]"><![CDATA[<p>Fired inside the <code>userProviders</code> container in the Spam sub-container.</p>]]></event>
  <event event_id="spam_user_submitter" arguments="[{&quot;name&quot;:&quot;$container&quot;,&quot;type&quot;:&quot;\\XF\\SubContainer\\Spam&quot;,&quot;description&quot;:&quot;Spam sub-container object&quot;},{&quot;name&quot;:&quot;$parentContainer&quot;,&quot;type&quot;:&quot;\\XF\\Container&quot;,&quot;description&quot;:&quot;Parent container&quot;},{&quot;name&quot;:&quot;&amp;$checker&quot;,&quot;type&quot;:&quot;\\XF\\Spam\\UserChecker&quot;,&quot;description&quot;:&quot;Spam checker object&quot;}]"><![CDATA[<p>Fired inside the <code>userSubmitter</code> container in the Spam sub-container. The <code>$checker</code> object allows you to add additional providers which will be used to submit details of spam users.</p>]]></event>
  <event event_id="string_data_lower_accents" arguments="[{&quot;name&quot;:&quot;&amp;$lowerAccents&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Map of lower case accented characters to their lower case ASCII replacement&quot;}]"><![CDATA[<p>Allows the modification of the map of lower cased accent conversions as defined in <code>XF\Data\Str</code>. This allows you to map any accented lower case character to any ASCII character.</p>]]></event>
  <event event_id="string_data_romanization" arguments="[{&quot;name&quot;:&quot;&amp;$romanization&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Map of characters to their ASCII replacement&quot;}]"><![CDATA[<p>Allows the modification of the map of romanization conversions as defined in <code>XF\Data\Str</code>. This allows you to map any character to any ASCII character.</p>]]></event>
  <event event_id="string_data_upper_accents" arguments="[{&quot;name&quot;:&quot;&amp;$upperAccents&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Map of upper case accented characters to their upper case ASCII replacement&quot;}]"><![CDATA[<p>Allows the modification of the map of upper cased accent conversions as defined in <code>XF\Data\Str</code>. This allows you to map any accented upper case character to any ASCII character.</p>]]></event>
  <event event_id="string_formatter_setup" arguments="[{&quot;name&quot;:&quot;$container&quot;,&quot;type&quot;:&quot;\\XF\\Container&quot;,&quot;description&quot;:&quot;Dependency injection container object&quot;},{&quot;name&quot;:&quot;&amp;$formatter&quot;,&quot;type&quot;:&quot;\\XF\\Str\\Formatter&quot;,&quot;description&quot;:&quot;The String formatter object&quot;}]"><![CDATA[<p>Fired when the String formatter object has been setup.</p>]]></event>
  <event event_id="templater_extension_post_render" arguments="[{&quot;name&quot;:&quot;$templater&quot;,&quot;type&quot;:&quot;\\XF\\Template\\Templater&quot;,&quot;description&quot;:&quot;Templater object&quot;},{&quot;name&quot;:&quot;$type&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Template type&quot;},{&quot;name&quot;:&quot;$template&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Template name&quot;},{&quot;name&quot;:&quot;$name&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Extension name. Note that if the extension is within a macro, this name will be macro_id:extension_id&quot;},{&quot;name&quot;:&quot;&amp;$output&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Rendered output&quot;}]" hint_description="A string representing the template type, template name and extension name, e.g. public:template_name:name. Note that the name value takes the same format as the name argument."><![CDATA[<p>Allows the modification of the rendered extension output.</p>]]></event>
  <event event_id="templater_extension_pre_render" arguments="[{&quot;name&quot;:&quot;$templater&quot;,&quot;type&quot;:&quot;\\XF\\Template\\Templater&quot;,&quot;description&quot;:&quot;Templater object&quot;},{&quot;name&quot;:&quot;$type&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Template type&quot;},{&quot;name&quot;:&quot;$template&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Template name&quot;},{&quot;name&quot;:&quot;$name&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Extension name. Note that if the extension is within a macro, this name will be macro_id:extension_id&quot;},{&quot;name&quot;:&quot;&amp;$params&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of parameters available to this extension&quot;}]" hint_description="A string representing the template type, template name and extension name, e.g. public:template_name:name. Note that the name value takes the same format as the name argument."><![CDATA[<p>Allows the modification of various properties for template extensions before they are rendered.</p>]]></event>
  <event event_id="templater_global_data" arguments="[{&quot;name&quot;:&quot;$app&quot;,&quot;type&quot;:&quot;\\XF\\App&quot;,&quot;description&quot;:&quot;Global App object&quot;},{&quot;name&quot;:&quot;&amp;$data&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Global template data&quot;},{&quot;name&quot;:&quot;$reply&quot;,&quot;type&quot;:&quot;\\XF\\Mvc\\Reply\\AbstractReply|null&quot;,&quot;description&quot;:&quot;This may contain the \\XF\\Mvc\\Reply\\AbstractReply object from the controller. It may not be available; null will be provided instead&quot;}]"><![CDATA[<p>Allows the global template data to be manipulated. This is the data available to templates under the <code>{$xf}</code> param.</p>]]></event>
  <event event_id="templater_macro_post_render" arguments="[{&quot;name&quot;:&quot;$templater&quot;,&quot;type&quot;:&quot;\\XF\\Template\\Templater&quot;,&quot;description&quot;:&quot;Templater object&quot;},{&quot;name&quot;:&quot;$type&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Template type&quot;},{&quot;name&quot;:&quot;$template&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Template name&quot;},{&quot;name&quot;:&quot;$name&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Macro ID&quot;},{&quot;name&quot;:&quot;&amp;$output&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Rendered output&quot;}]" hint_description="A string representing the template type, template name and macro ID, e.g. public:template_name:macro_id."><![CDATA[<p>Allows the modification of the rendered macro output.</p>]]></event>
  <event event_id="templater_macro_pre_render" arguments="[{&quot;name&quot;:&quot;$templater&quot;,&quot;type&quot;:&quot;\\XF\\Template\\Templater&quot;,&quot;description&quot;:&quot;Templater object&quot;},{&quot;name&quot;:&quot;&amp;$type&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Template type&quot;},{&quot;name&quot;:&quot;&amp;$template&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Template name&quot;},{&quot;name&quot;:&quot;&amp;$name&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Macro ID&quot;},{&quot;name&quot;:&quot;&amp;$arguments&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of arguments passed to this macro&quot;},{&quot;name&quot;:&quot;&amp;$globalVars&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of global vars available to this macro&quot;}]" hint_description="A string representing the template type, template name and macro ID, e.g. public:template_name:macro_id."><![CDATA[<p>Allows the modification of various properties for template macros before they are rendered.</p>]]></event>
  <event event_id="templater_setup" arguments="[{&quot;name&quot;:&quot;$container&quot;,&quot;type&quot;:&quot;\\XF\\Container&quot;,&quot;description&quot;:&quot;Dependency injection container object&quot;},{&quot;name&quot;:&quot;&amp;$templater&quot;,&quot;type&quot;:&quot;\\XF\\Template\\Templater&quot;,&quot;description&quot;:&quot;The Templater object. Note: This could also be the Mailer templater&quot;}]"><![CDATA[<p>Fired when the Templater object has been setup.</p>]]></event>
  <event event_id="templater_template_post_render" arguments="[{&quot;name&quot;:&quot;$templater&quot;,&quot;type&quot;:&quot;\\XF\\Template\\Templater&quot;,&quot;description&quot;:&quot;Templater object&quot;},{&quot;name&quot;:&quot;$type&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Template type&quot;},{&quot;name&quot;:&quot;$template&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Template name&quot;},{&quot;name&quot;:&quot;&amp;$output&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Rendered output&quot;}]" hint_description="A string representing the template type and name, e.g. public:template_name."><![CDATA[<p>Allows the modification of the rendered template output.</p>]]></event>
  <event event_id="templater_template_pre_render" arguments="[{&quot;name&quot;:&quot;$templater&quot;,&quot;type&quot;:&quot;\\XF\\Template\\Templater&quot;,&quot;description&quot;:&quot;Templater object&quot;},{&quot;name&quot;:&quot;&amp;$type&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Template type&quot;},{&quot;name&quot;:&quot;&amp;$template&quot;,&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Template name&quot;},{&quot;name&quot;:&quot;&amp;$params&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of parameters passed into this template&quot;}]" hint_description="A string representing the template type and name, e.g. public:template_name."><![CDATA[<p>Allows the modification of various properties for templates before they are rendered.</p>]]></event>
  <event event_id="user_content_change_init" arguments="[{&quot;name&quot;:&quot;$changeService&quot;,&quot;type&quot;:&quot;\\XF\\Service\\User\\ContentChangeService&quot;,&quot;description&quot;:&quot;The service being initialized&quot;},{&quot;name&quot;:&quot;&amp;$updates&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;A list of tables and columns within that need to be updated when this service runs&quot;}]"><![CDATA[<p>Fired inside the constructor for the <code>\XF\Service\User\ContentChangeService</code> class.</p>

<p>This allows you to add extra tables and columns that should be updated when a user is renamed, deleted or merged. Note that adding steps requires a class extension.</p>]]></event>
  <event event_id="user_content_change_steps" arguments="[{&quot;name&quot;:&quot;&amp;$steps&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;List of step callables or method names&quot;},{&quot;name&quot;:&quot;$contentChange&quot;,&quot;type&quot;:&quot;\\XF\\Service\\User\\ContentChangeService&quot;,&quot;description&quot;:&quot;User content change service&quot;}]"><![CDATA[<p>Called when determining the user content change steps.</p>

<p>Example:</p>
<pre>public static function userContentChangeSteps(
	array &$steps,
	\XF\Service\User\ContentChangeService $contentChange
): void
{
	$steps[] = function (?int $lastOffset, float $maxRunTime) use ($contentChange): ?int
	{
		// your user content change logic
		return null;
	};
}</pre>]]></event>
  <event event_id="user_delete_clean_init" arguments="[{&quot;name&quot;:&quot;$deleteService&quot;,&quot;type&quot;:&quot;\\XF\\Service\\User\\DeleteCleanUpService&quot;,&quot;description&quot;:&quot;The service being initialized&quot;},{&quot;name&quot;:&quot;&amp;$deletes&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;A list of tables and where clauses representing content to be removed when a user is deleted&quot;}]"><![CDATA[<p>Fired inside the constructor of the <code>\XF\Service\User\DeleteCleanUpService</code> class.</p>

<p>This allows you to add extra queries to clean up content from a user deletion. Note that adding steps requires a class extension.</p>]]></event>
  <event event_id="user_delete_clean_steps" arguments="[{&quot;name&quot;:&quot;&amp;$steps&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;List of step callables or method names&quot;},{&quot;name&quot;:&quot;$deleteCleanUp&quot;,&quot;type&quot;:&quot;\\XF\\Service\\User\\DeleteCleanUpService&quot;,&quot;description&quot;:&quot;User delete clean-up service&quot;}]"><![CDATA[<p>Called when determining the user delete clean-up steps.</p>

<p>Example:</p>
<pre>public static function userDeleteCleanSteps(
	array &$steps,
	\XF\Service\User\DeleteCleanUpService $deleteCleanUp
): void
{
	$steps[] = function (?int $lastOffset, float $maxRunTime) use ($deleteCleanUp): ?int
	{
		// your user delete clean-up logic
		return null;
	};
}</pre>]]></event>
  <event event_id="user_merge_combine" arguments="[{&quot;name&quot;:&quot;$target&quot;,&quot;type&quot;:&quot;\\XF\\Entity\\User&quot;,&quot;description&quot;:&quot;The target user (the user being merged into)&quot;},{&quot;name&quot;:&quot;$source&quot;,&quot;type&quot;:&quot;\\XF\\Entity\\User&quot;,&quot;description&quot;:&quot;The source user (the user being merged from). This user will be deleted at the end of the process&quot;},{&quot;name&quot;:&quot;$mergeService&quot;,&quot;type&quot;:&quot;\\XF\\Service\\User\\MergeService&quot;,&quot;description&quot;:&quot;The service being used to do the merge&quot;}]"><![CDATA[<p>Fired inside the <code>\XF\Service\User\MergeService</code> class in the <code>combineData()</code> method.</p>

<p>This allows you to add extra fields whose values should be combined while doing a user merge.</p>]]></event>
  <event event_id="user_merge_steps" arguments="[{&quot;name&quot;:&quot;&amp;$steps&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;List of step callables or method names&quot;},{&quot;name&quot;:&quot;$merge&quot;,&quot;type&quot;:&quot;\\XF\\Service\\User\\MergeService&quot;,&quot;description&quot;:&quot;User merge service&quot;}]"><![CDATA[<p>Called when determining the user merge steps.</p>

<p>Example:</p>
<pre>public static function userMerge(
	array &$steps,
	\XF\Service\User\MergeService $merge
): void
{
	$steps[] = function (?int $lastOffset, float $maxRunTime) use ($merge): ?int
	{
		// your user merge logic
		return null;
	};
}</pre>]]></event>
  <event event_id="user_searcher_orders" arguments="[{&quot;name&quot;:&quot;$userSearcher&quot;,&quot;type&quot;:&quot;\\XF\\Searcher\\User&quot;,&quot;description&quot;:&quot;User searcher object&quot;},{&quot;name&quot;:&quot;&amp;$sortOrders&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of existing sort order fields&quot;},{&quot;name&quot;:&quot;&amp;$stringSortOrders&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;Array of existing string sort order fields&quot;}]"><![CDATA[<p>Fired inside the <code>XF\Searcher\User</code> class in the <code>getDefaultOrderOptions()</code> method.</p>

<p>This allows you to add additional fields that users can be ordered by. This affects user searches in the control panel and member stats. If you are adding a string based sort order which may be used in member stats, it should be marked as string-based in the <code>$stringSortOrders</code> array.</p>]]></event>
  <event event_id="visitor_extra_with" arguments="[{&quot;name&quot;:&quot;&amp;$with&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;array of relations to be fetched from the User entity&quot;}]"><![CDATA[<p>Called when determining what extra relations to include when fetching the visitor User entity.</p>

<p>This will only be called for registered members.</p>]]></event>
  <event event_id="visitor_guest_setup" arguments="[{&quot;name&quot;:&quot;&amp;$defaultData&quot;,&quot;type&quot;:&quot;array&quot;,&quot;description&quot;:&quot;The default data to be added to the guest User entity and its relations. Add new values to the User entity: $defaultData['keyName'] = 'value'; Add new values to the entity's relations: $defaultData['_relations']['relationName']['keyName'] = 'value';&quot;}]"><![CDATA[<p>Called when the default data for the guest User entity object is being prepared.</p>

<p>
	<b>Note:</b> Any values added to the default data should be encoded as if they have been stored in the database. For example, if the column is JSON encoded, you should provide the JSON string rather than a PHP array.
</p>]]></event>
  <event event_id="visitor_setup" arguments="[{&quot;name&quot;:&quot;&amp;$visitor&quot;,&quot;type&quot;:&quot;\\XF\\Entity\\User&quot;,&quot;description&quot;:&quot;The visitor's User entity. From this, you can inspect the user, their permissions, profile fields, and all User entity relations.&quot;}]"><![CDATA[<p>Called when the visitor's User entity has been prepared.</p>

<p>This will be called for registered members and guests.</p>]]></event>
</code_events>
